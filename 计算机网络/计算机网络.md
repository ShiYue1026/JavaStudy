# 基础

## 说下计算机网络体系结构

计算机网络体系结构通过将复杂的网络通信分解成不同的层次，来标准化交互的过程。常见的模型给包括**OSI七层模型**、**TCP/IP四层模型**和**五层体系结构**。

![三分恶面渣逆袭：三种网络体系结构](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-11ecdc9c-5a06-4429-bfc4-115793749000.jpg)

OSI 是理论上的网络通信模型，TCP/IP 是实际应用层面上的网络通信模型，五层结构是为了方便理解和记忆。



## 详细介绍下OSI七层模型

**应用层**

- 最靠近用户的层，负责处理特定的应用程序细节。这一层提供了**网络服务与用户应用软件之间的接口**。例如，Web 浏览器、FTP 客户端和服务器、电子邮件客户端等。

**表示层**

- 确保从一个系统发送的信息可以被另一个系统的应用层读取。它负责**数据的转换、压缩和加密**。例如，确保数据从一种编码格式转换为另一种，如 ASCII 到 EBCDIC。

**会话层**

- 管理用户的会话，控制网络上两节点间的对话和数据交换的管理。它负责**建立、维护和终止会话**。例如，建立一个会话令牌，以便在网络上的两个节点之间传递。

**传输层**

- 提供**端到端的通信服务**，保证数据的完整性和正确顺序。这一层包括 TCP 和 UDP 等。

**网络层**

- 负责在**多个网络之间进行数据传输**，确保数据能够在复杂的网络结构中找到从源到目的地的最佳路径。这层使用的是 IP（Internet Protocol）协议。

**数据链路层**

- 在物理连接中提供可靠的传输，**负责建立和维护两个相邻节点间的链路**。包括帧同步、MAC（媒体访问控制）。

**物理层**

- 负责**在物理媒介上实现原始的数据传输**，比如电缆、光纤和无线信号传输。涉及的内容包括电压、接口、针脚、电缆的规格和传输速率等。



## 详细介绍下TCP/IP四层模型

**应用层**：直接面向用户和应用程序，提供各种网络服务。它包含了用于特定应用的协议和服务，如 HTTP（HyperText Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）等。

**传输层**：提供端到端的通信服务，确保数据可靠传输。它负责分段数据、流量控制、错误检测和纠正。常见的传输层协议有 TCP 和 UDP。

**网络层**：负责在不同网络之间路由数据包，提供逻辑地址（IP 地址）和网络寻址功能。用于处理数据包的分组、转发和路由选择，确保数据可以从源端传输到目标端。

**网络接口层**：链路层（Link Layer），负责将数字信号在物理通道（网线）中准确传输，定义了如何在单一网络链路上传输数据，如何处理数据帧的发送和接收，包括物理地址（MAC 地址）的解析。



## 详细介绍下五层体系结构

是对 OSI 和 TCP/IP 的折衷，它保留了 TCP/IP 的实用性，同时提供了比四层模型更细致的分层，便于教学和理解网络的各个方面。



## 每一层对应的网络协议有哪些

![各层网络对应的网络协议](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-ad64bbac-e0d5-4286-9b77-d008e8c8d419.jpg)

## 数据在各层之间是怎么传输的

对于发送方：从上层到下，层层包装

对于接收方：从下层到上层，层层解开包装

![数据在各层之间的传输](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg)

- 发送方的应用进程向接收方的应用进程传送数据
- AP 先将数据交给本主机的应用层，应用层加上本层的控制信息 H5 就变成了下一层的数据单元
- 传输层收到这个数据单元后，加上本层的控制信息 H4，再交给网络层，成为网络层的数据单元
- 到了数据链路层，控制信息被分成两部分，分别加到本层数据单元的首部（H2）和尾部（T2）
- 最后的物理层，进行比特流的传输



# 网络综合

## 从浏览器地址栏输入url到显示网页的过程了解吗

这个过程包括了多个步骤，涵盖了DNS解析、TCP连接、发送HTTP请求、服务器处理请求并返回HTTP响应、浏览器处理响应并渲染页面等多个环节。

![三分恶面渣逆袭：www.baidu.com URL 到显示主页](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-c2c19567-dec4-4dbd-9a6e-4c0e52070ed6.jpg)

**1. DNS解析**

浏览器需要把域名转换成服务器IP地址

- 浏览器检查**本地DNS缓存**
- 如果缓存没有，查询**操作系统的DNS解析器**
- 如果本地没有，向**本地DNS服务器**发送查询请求
- 本地DNS服务器可能缓存了该域名的IP地址，否则向**根DNS服务器**请求
- 根DNS服务器返回**顶级域名服务器**（.com服务器）的地址
- 顶级域名服务器告诉本地 DNS 服务器去找 **权威 DNS 服务器**（example.com 的 DNS 服务器）。
- 权威DNS服务器返回example.com的IP地址

**2. TCP连接**

浏览器使用**TCP三次握手**连接服务器

- **客户端 → 服务器**：发送 `SYN` 请求，表示要建立连接。

- **服务器 → 客户端**：返回 `SYN-ACK`，表示同意建立连接。

- **客户端 → 服务器**：返回 `ACK`，连接建立。

**3. 发送HTTP/HTTPS请求**

- **如果是 HTTPS**，在 TCP 连接后会先进行 **TLS/SSL 握手**（加密通信）。

- 发送 `GET` 请求：

  ```http
  GET / HTTP/1.1
  Host: www.example.com
  User-Agent: Mozilla/5.0
  Accept: text/html,application/xhtml+xml
  ```

- 服务器解析请求，查找资源，并返回响应。

**4. 服务器处理请求**

**5. 服务器返回HTTP响应**

```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 1024
Connection: keep-alive

<html>
  <head><title>Example</title></head>
  <body>Hello, World!</body>
</html>

```

**6. 浏览器解析HTML并渲染页面**

**7. 连接关闭**

如果是 **HTTP/1.1**，连接会保持 **Keep-Alive**，避免频繁建立 TCP 连接。

否则会话结束，服务器和浏览器 **关闭连接**（TCP 四次挥手）。



## 说说DNS的解析过程

DNS 的全称是 **Domain Name System**，也就是域名解析系统，它可以将域名映射到对应的 IP 地址上

![三分析面渣逆袭：DNS 解析流程](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-03408af8-3ca8-49bd-9244-6afa6fe132c6.jpg)



## 说说WebSocket和Socket的区别

WebSocket 一种基于 TCP 的双向通信协议，它可以让**浏览器和服务器之间保持长连接**，适用于实时应用。且是全双工的（全双工通信：浏览器和服务器可以随时主动发送数据，不像 HTTP 需要客户端请求后服务器才能响应。）

Socket是 操作系统提供的通用网络通信接口，用于在两个设备之间传输数据（不限于浏览器和服务器）。所有网络协议（如 HTTP、FTP、SSH）都基于 Socket。

总的来说，Socket 一个是**网编编程的标准接口**，而 WebSocket 则是**应用层通信协议**。



## 说一下你了解的端口及对应的服务

| 端口 |      服务       |
| :--: | :-------------: |
|  22  |       SSH       |
|  53  | DNS域名解析服务 |
|  80  |      HTTP       |
| 443  |      HTTPS      |
| 3306 | MySQL默认端口号 |



## 平常有抓包吗

平常使用最多的就是 chrome 浏览器自带的 network 面板了，可以看到请求的时间、请求的信息，以及响应信息。

![image-20250210112047670](https://github.com/user-attachments/assets/3eed7d90-e841-41c6-b021-eb2c43b16867)


更专业的还有 fiddler、wireshark 等工具。



# HTTP

## 说说HTTP常用的状态码及其含义

**1xx**：服务器收到请求，需要继续处理

- **101**：切换请求协议

**2xx**：表示请求成功

- **200**：请求成功

**3xx**：重定向，客户端需执行进一步操作

- **301**：请求资源永久移动，返回新URI
- **302**：请求资源临时移动，继续使用原有URI

**4xx**：客户端错误，请求有问题

- **400**：请求错误，语法错误或参数错误等
- **401**：未授权，当前请求需要认证
- **403**：禁止访问，服务器拒绝请求（权限不足）
- **404**：访问的URL不存在
- **405**：`GET/POST/PUT/DELETE` 请求方式错误

**5xx**：服务端错误，服务器处理请求失败

- **500**：服务器内部错误



## HTTP有哪些请求方式

**GET**

- 请求检索指定的资源。应该只用于获取数据，并且是幂等的，即多次执行相同的 GET 请求应该返回相同的结果，并且不会改变资源的状态。
- 幂等

**POST**

- 向指定资源提交数据，请求服务器进行处理（如提交表单或上传文件）。数据被包含在请求体中。可能会创建新的资源或修改现有资源。
- 非幂等

**DELETE**

- 删除指定的资源。
- 幂等

**PUT**

- 用于替换指定的资源。如果指定的资源不存在，创建一个新资源。
- 幂等

**HEAD**

- 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。可以用于检查资源是否存在，验证资源的更新时间等。

**OPTIONS**

- 客户端请求

  ```http
  OPTIONS /users/123 HTTP/1.1
  Host: example.com
  ```

- 服务器响应

  ```http
  HTTP/1.1 204 No Content
  Allow: GET, POST, PUT, DELETE, OPTIONS
  ```



## HTTP的GET方法可以实现写操作吗

GET方法可以实现写操作，因为GET请求可以 **携带 URL 参数**，有些服务器会解析这些参数执行写操作。但是并不安全，GET 执行写操作可能导致严重的安全问题，如**跨站请求伪造（CSRF）**。



## 说一下GET和POST的区别

GET 请求主要用于获取数据，参数附加在 URL 中，存在长度限制，且容易被浏览器缓存，有安全风险；而 POST 请求用于提交数据，参数放在请求体中，适合提交大量或敏感的数据。

另外，GET 请求是幂等的，多次请求不会改变服务器状态；而 POST 请求不是幂等的，可能对服务器数据有影响。



## GET的长度限制是多少

- HTTP 中的 GET 方法是通过 URL 传递数据的，但是 URL 本身其实并没有对数据的长度进行限制，**真正限制 GET 长度的是浏览器**。

- 例如 IE 浏览器对 URL 的最大限制是 2000 多个字符，大概 2kb 左右，像 Chrome、Firefox 等浏览器支持的 URL 字符数更多，其中 FireFox 中 URL 的最大长度限制是 65536 个字符，Chrome 则是 8182 个字符。

- 这个长度限制也不是针对数据部分，而是针对整个 URL。



## HTTP请求的过程与原理

**HTTP 是基于 TCP/IP 协议的应用层协议**，它使用 TCP 作为传输层协议，通过建立 TCP 连接来传输数据。

![三分恶面渣逆袭：HTTP 请求的过程和原理](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-9a1a42b7-c14a-43d8-b8d8-f1f18c9b923b.jpg)

- 在浏览器输入 URL 后，浏览器首先会通过 DNS 解析获取到服务器的 IP 地址，然后与服务器建立 TCP 连接。
- TCP 连接建立后，浏览器会向服务器发送 HTTP 请求。
- 服务器收到请求后，会根据请求的信息处理请求。
- 处理完请求后，服务器会返回一个 HTTP 响应给浏览器。
- 浏览器收到响应后，会根据响应的信息渲染页面。然后，浏览器和服务器断开 TCP 连接。

客户端发送一个请求到服务器，服务器处理请求并返回一个响应。这个过程是同步的，也就是说，客户端在发送请求后必须等待服务器的响应。在等待响应的过程中，客户端不会发送其他请求。



## 怎么利用多线程来下载一个数据呢？

可以采取分块下载的策略。首先，通过 HEAD 请求获取文件的总大小。然后根据文件大小和线程数，将文件进行切割。每个线程负责下载一个特定范围的数据。

**1. 获取文件大小**

```java
URL url = new URL("https://javabetter.cn/file.zip");
HttpURLConnection connection = (HttpURLConnection) url.openConnection();
connection.setRequestMethod("HEAD");
int fileSize = connection.getContentLength(); // 获取文件大小
connection.disconnect();
```

**2. 下载文件方法**

```java
public void downloadChunk(String url, int start, int end, String outputPath) {
    try {
        URL fileUrl = new URL(url);
        HttpURLConnection connection = (HttpURLConnection) fileUrl.openConnection();
        connection.setRequestProperty("Range", "bytes=" + start + "-" + end);

        InputStream inputStream = connection.getInputStream();
        RandomAccessFile file = new RandomAccessFile(outputPath, "rw");
        file.seek(start); // 定位到文件的相应位置

        byte[] buffer = new byte[1024];
        int bytesRead;
        while ((bytesRead = inputStream.read(buffer)) != -1) {
            file.write(buffer, 0, bytesRead);
        }

        file.close();
        inputStream.close();
        connection.disconnect();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

**3. 启动多线程下载**

```java
int numThreads = 4;
int fileSize = 100000000; // 假设文件大小为 100MB
int chunkSize = fileSize / numThreads;
String url = "https://javabetter.cn/file.zip";
String outputPath = "path/to/local/file.zip";

ExecutorService executor = Executors.newFixedThreadPool(numThreads);
for (int i = 0; i < numThreads; i++) {
    int start = i * chunkSize;
    int end = (i == numThreads - 1) ? fileSize - 1 : (start + chunkSize - 1);
    executor.execute(() -> downloadChunk(url, start, end, outputPath));
}
executor.shutdown();
```



## 说一下HTTP的报文结构

HTTP 的报文结构分为：请求报文和响应报文。

两者在结构上很相似，都包含了**起始行**、**头部**和**消息正文**。



**请求报文**

```http
GET /index.html HTTP/1.1
Host: www.javabetter.cn
Accept: text/html
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3
```

- 请求行包括**请求方法、请求 URL 和 HTTP 协议的版本**。例如：`GET /index.html HTTP/1.1`。

- 请求头部包含请求的附加信息，如客户端想要接收的内容类型、浏览器类型等。例如：
  - `Host: www.javabetter.cn`，表示请求的主机名（域名）
  - `Accept: text/html`，表示客户端可以接收的媒体类型
  - `User-Agent: Mozilla/5.0`，表示客户端的浏览器类型
  - `Range`：用于指定请求内容的范围，如断点续传时表示请求的字节范围。

- 请求头部和消息正文之间有一个空行，表示请求头部结束
- 消息正文是可选的，如 POST 请求中的表单数据；GET 请求中没有消息正文。



**响应报文**

```http
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84
<html>
  <body>沉默王二很天真</body>
</html>
```

- 状态行包括 **HTTP 协议的版本、状态码**（如 200、404）和**状态消息**（如 OK、NotFound）。例如：`HTTP/1.0 200 OK`。

- 响应头包含响应的附加信息，如**服务器类型、内容类型、内容长度**等。也是键值对，例如：

- 响应头部和消息正文之间有一个空行，表示响应头部结束
- 响应的具体内容，如 HTML 页面。不是所有的响应都有消息正文，如 204 No Content 状态码的响应。



## URI和URL有什么区别

![URI 和 URL](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-fee87ab7-0475-429b-aba6-7a8df6841572.jpg)

- URI，统一资源标识符(Uniform Resource Identifier， URI)，标识的是 Web 上每一种可用的资源，如 HTML 文档、图像、视频片段、程序等都是由一个 URI 进行标识的。
- URL，统一资源定位符（Uniform Resource Location），它是 URI 的一种子集，主要作用是提供资源的路径。



它们的主要区别在于，URL 除了提供了资源的标识，还提供了资源访问的方式。



## 说下HTTP/1.0，1.1，2.0的区别

HTTP/1.0采用**短链接**

HTTP/1.1采用**长连接**

HTTP/2.0采用**多路复用**

![bytebytego：HTTP 协议的进化](https://cdn.tobebetterjavaer.com/stutymore/network-20241225094527.png)

**HTTP1.0**

- **无状态协议**：HTTP/1.0 是无状态的，每个请求之间相互独立，服务器不保存任何请求的状态信息。
- **非持久连接**：默认情况下，每个 HTTP 请求/响应对之后，连接会被关闭，属于短连接。可以设置`Connection: keep-alive` 强制开启长连接。

**HTTP1.1**

- **持久连接**：HTTP/1.1 引入了持久连接（也称为 HTTP keep-alive），默认情况下不会立即关闭连接，可以在一个连接上发送多个请求和响应。极大减轻了 TCP 连接的开销。
- **流水线处理**：HTTP/1.1 支持客户端在前一个请求的响应到达之前发送下一个请求，以提高传输效率。

**HTTP2.0**

- **二进制协议**：HTTP/2.0 使用二进制而不是文本格式来传输数据，解析更加高效。
- **多路复用**：一个 TCP 连接上可以同时进行多个 HTTP 请求/响应，解决了 HTTP/1.x 的队头阻塞问题。
- **头部压缩**：HTTP 协议不带状态，所以每次请求都必须附上所有信息。HTTP/2.0 引入了头部压缩机制，可以使用 gzip 或 compress 压缩后再发送，减少了冗余头部信息的带宽消耗。
- **服务端推送**：服务器可以主动向客户端推送资源，而不需要客户端明确请求。



![image-20250210123237343](https://github.com/user-attachments/assets/1a1e86fd-aea2-4724-ab96-2536231735f9)


**HTTP/2.0队头阻塞示例**

```
流 1（请求 HTML） ---> TCP 传输中丢失数据
流 2（请求 CSS） ---> 必须等待 TCP 重传
流 3（请求 JS） ---> 必须等待 TCP 重传
```

即使 `流 2` 和 `流 3` 没有丢包，它们仍然必须等待 `流 1` 的丢失数据重传，导致所有请求被阻塞！



## HTTP/3.0了解吗

HTTP/2.0 基于 TCP 协议，而 HTTP/3.0 则基于 QUIC 协议，Quick UDP Connections，直译为快速 UDP 网络连接。

基于 TCP 的 HTTP/2.0，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输的过程中，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，仍然会阻塞在它之后传输的流数据。

而基于 UDP 的 QUIC 协议可以更彻底地解决这样的问题，让不同的流之间真正的实现相互独立传输，互不干扰。



**目前使用最广泛的是哪个HTTP版本？**

HTTP2.0



## HTTP长连接了解吗

在 HTTP 中，长连接是指客户端和服务器之间在一次 HTTP 通信完成后，不会立即断开，而是保留连接以供后续请求复用。

这种机制可以减少了频繁建立和关闭连接的开销



**如何设置长连接**

可以通过 Connection: keep-alive 实现。在 HTTP/1.1 中，长连接是默认开启的。



## HTTP长连接什么时候会超时

- HTTP 一般会有 httpd 守护进程，里面可以设置 **keep-alive timeout**，当 tcp 连接闲置超过这个时间就会关闭，也可以**在 HTTP 的 header 里面设置超时时间**
- TCP 的 **keep-alive** 包含三个参数，支持在系统内核的 net.ipv4 里面设置；当 TCP 连接之后，闲置了 **tcp_keepalive_time**，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 **tcp_keepalive_intvl** 再发一次，直到发送了 **tcp_keepalive_probes**次，就会丢弃该连接。

```
1. tcp_keepalive_intvl = 15
2. tcp_keepalive_probes = 5
3. tcp_keepalive_time = 1800
```



## 说说HTTP与HTTPS有哪些区别

HTTPS 是 HTTP 的增强版，在 HTTP 的基础上加入了 SSL/TLS 协议，确保数据在传输过程中是加密的。

![二哥的 Java 进阶之路：http和 https 的区别](https://cdn.tobebetterjavaer.com/stutymore/network-20240418120939.png)

HTTP 的默认端⼝号是 80，URL 以`http://`开头；HTTPS 的默认端⼝号是 443，URL 以`https://`开头。



HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。



## 为什么要用HTTPS

HTTP 是明文传输的，存在数据窃听、数据篡改和身份伪造等问题。而 HTTPS 通过引入 SSL/TLS，解决了这些问题。

SSL/TLS 在加密过程中涉及到了两种类型的加密方法：

- **非对称加密**：服务器向客户端发送公钥，然后客户端用公钥加密自己的随机密钥，也就是会话密钥，发送给服务器，服务器用私钥解密，得到会话密钥。
  - 私钥由服务器保管
  - 服务器会向客户端颁发对应的公钥，如果客户端收到消息能被公钥解密，就说明该消息是由服务器发送的
- **对称加密**：双方用会话密钥加密通信内容。

![数子证书工作流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

![二哥的Java进阶之路：HTTPS 连接建立过程](https://cdn.tobebetterjavaer.com/stutymore/network-20240418124713.png)

HTTPS 的连接建立在 SSL/TLS 握手之上，其过程可以分为两个阶段：握手阶段和数据传输阶段。

①、客户端向服务器发起请求

②、服务器接收到请求后，返回自己的数字证书，包含了公钥、颁发机构等信息。

③、客户端收到服务器的证书后，验证证书的合法性，如果合法，会生成一个随机码，然后用服务器的公钥加密这个随机码，发送给服务器。

④、服务器收到会话密钥后，用私钥解密，得到会话密钥。

⑤、客户端和服务器通过会话密码对通信内容进行加密，然后传输。

如果通信内容被截取，但由于没有会话密钥，所以无法解密。当通信结束后，连接会被关闭，会话密钥也会被销毁，下次通信会重新生成一个会话密钥。



## HTTPS会加密URL吗

HTTPS 通过 SSL/TLS 协议确保了客户端与服务器之间交换的数据被加密，这包括 HTTP 头部和正文。

而 URL 是 HTTP 头部的一部分，因此这部分信息也是加密的。



## 什么是中间人攻击

中间人攻击（Man-in-the-Middle, MITM）是一种常见的网络安全威胁，攻击者可以在通信的两端插入自己，以窃取通信双方的信息。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.png)

HTTPS就是通过中间人进行抓包的



## HTTPS怎么保证建立的信道是安全的

主要通过 SSL/TLS 协议的多层次安全机制，首先在握手阶段，客户端和服务器使用得是非对称加密，生成的会话密钥只有服务器的私钥才能解密，而私钥只有服务器持有。

在数据传输阶段，即使攻击者拦截了通信数据，没有会话密钥也无法解密。



## 客户端怎么验证证书的合法性





