# MySQL基础

## MySQL性能差的原因有哪些

- 全表扫描，

- 未正确使用索引
- 查询语句过于复杂，如多表 JOIN 或嵌套子查询。

- 单表数据量过大，导致查询效率降低。



## 数据库的三大范式是什么

三大范式的作用是为了减少数据冗余，提高数据完整性。

**第一范式**

- 确保表的每一列都是不可分割的基本数据单元，比如说用户地址，应该拆分成省、市、区、详细信息等 4 个字段。

**第二范式**

- 每个非主键字段必须完全依赖于主键，而不能是部分依赖。

**第三范式**

- 非主键字段必须直接依赖于主键，而不能通过另一个非主键字段传递依赖。



## 什么场景下不用遵循三大范式

**1. 查询频繁、性能要求高的业务场景**

- 在 **大数据量、查询频率高** 的情况下，过多的表关联（JOIN）操作会降低查询性能。
- **适当冗余一些字段**，避免频繁 `JOIN`，可以提高查询效率。

**2. 数据写入远少于读取的场景（以读为主）**

- 例如 **电商系统的订单记录**，订单创建后不会频繁修改，但需要**快速查询**，可以适当冗余数据。





## 建表的时候考虑哪些问题

- 在建表的时候，首先可以考虑表是否符合数据库范式，也就是确保字段不可再分，消除非主键依赖，确保字段仅依赖于主键。
- 选择字段类型时，尽量选择合适的数据类型。
- 字符集上，尽量选择 utf8mb4，这样不仅可以支持中文和英文，还可以支持表情符号等。
- 当数据量较大时（比如上千万行数据），需要考虑分表。比如订单表，可以采用水平分表的方式来分散存储压力。



## char和varchar的区别

![varchar](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/mysql-40f42d59-a295-4543-8a03-43925da4d6d9.jpg)

- 因为长度固定，所以char的存取速度要比 varchar 快很多，甚至能快 50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；

对于长度相对固定的字符串，可以使用 char，对于长度不确定的，使用 varchar 更合适一些。



## blob和text有什么区别

**blob**

- 二进制数据（如图片、音频、视频、PDF）
- 不使用字符集，存储原始字节
- 区分大小写

**text**

- 文本数据（如文章、日志、JSON）
- 使用字符集，存储文本
- 不区分大小写



## DATETIME和TIMESTAMP有什么区别

**相同点**

- 两个数据类型存储时间的表现格式一致。均为 `YYYY-MM-DD HH:MM:SS`
- 两个数据类型都包含「日期」和「时间」部分。
- 两个数据类型都可以存储微秒的小数秒（秒后 6 位小数秒）

**不同点**

- **日期范围**：DATETIME 的日期范围是 `1000-01-01 00:00:00.000000` 到 `9999-12-31 23:59:59.999999`；TIMESTAMP 的时间范围是`1970-01-01 00:00:01.000000` UTC `到 ``2038-01-09 03:14:07.999999` UTC
- **存储空间**：DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节
- **时区相关**：DATETIME 存储时间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区
- **默认值**：DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空(not null)，默认值为当前时间(CURRENT_TIMESTAMP)



## in 和 exists 的区别

**in**

- 子查询先执行，返回完整数据集，主查询匹配
- 子查询结果小（<1000 条）时更快

**exisits**

- 外层表逐行检查，子查询找到一条匹配就终止
- 外层表大时更快（避免全表扫描）



## 记录货币用什么字段比较好

货币在数据库中 MySQL 常用 Decimal 和 Numeric 类型表示，这两种类型被 MySQL 实现为同样的类型。他们被用于保存与货币有关的数据。

例如 salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于存储小数点后的位数。存储在 salary 列中的值的范围是从-9999999.99 到 9999999.99。

**DECIMAL 和 NUMERIC 值作为字符串存储**，而不是作为二进制浮点数，以便保存那些值的小数精度。

之所以不使用 float 或者 double 的原因：因为 float 和 double 是以二进制存储的，所以有一定的误差。



## 怎么存储emoji

 emoji 表情（😊）是 4 个字节的 UTF-8 字符，所以在 MySQL 中存储 emoji 表情时，需要使用 utf8mb4 字符集。



## drop、delete和truncate的区别

| 区别     | delete                                   | truncate                       | drop                                               |
| :------- | :--------------------------------------- | :----------------------------- | :------------------------------------------------- |
| 类型     | 属于 DML                                 | 属于 DDL                       | 属于 DDL                                           |
| 回滚     | 可回滚                                   | 不可回滚                       | 不可回滚                                           |
| 删除内容 | 表结构还在，删除表的全部或者一部分数据行 | 表结构还在，删除表中的所有数据 | 从数据库中删除表，所有数据行，索引和权限也会被删除 |
| 删除速度 | 删除速度慢，需要逐行删除                 | 删除速度快                     | 删除速度最快                                       |



## 什么是DDL和DML

**DDL**（Data Definition Language）

- 用于定义和管理数据库结构（Schema），影响的是数据库对象（表、索引、视图等），DDL 语句会 自动提交，不可回滚。

**DML**（Data Manipulation Language）

- 用于操作表中的数据（CRUD：增删改查），影响的是数据本身，DML 语句 不会自动提交，可以回滚（ROLLBACK）



# 事务

## 什么是事务

**事务**是一组操作的集合，是一个不可分割的工作单位，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，**要么同时成功，要么同时失败**



## 什么是事务的四大特性

**1. 原子性（Atomicity）**

- 事务是不可分割的最小操作单元，要么全部成功，要么全部失败

**2. 一致性（Consistency）**

- 事务完成时，必须使所有的数据保持一致状态

**3. 隔离性（Isolation）**

- 保证事务在不受外部并发操作影响的独立环境下运行

**4. 持久性（Durability）**

- 事务一旦提交或回滚，对数据库中的数据的改变就是永久的



## ACID靠什么保证

MySQL通过事务、undo log、redo log来确保ACID

![二哥的 Java 进阶之路：ACID 的保证机制](https://cdn.tobebetterjavaer.com/stutymore/mysql-20230919103025.png)

**保证原子性**

- 当事务开始时，MySQL 会在**undo log**中记录事务开始前的旧值。如果事务执行失败，MySQL 会使用**undo log**中的旧值来回滚事务开始前的状态；如果事务执行成功，MySQL 会在某个时间节点将**undo log**删除

**保证一致性**

- 如果其它三个特性得到了保证，一致性就自然而然得到保证

**保证隔离性**

- MySQL 定义了多种隔离级别，通过 **MVCC** 来确保每个事务都有专属自己的数据版本，从而实现隔离性

**保证持久性**

- **redo log** 是一种物理日志，当执行写操作时，MySQL 会先将更改记录到 **redo log** 中。当 **redo log** 填满时，MySQL 再将这些更改写入数据文件中。
- 如果 MySQL 在写入数据文件时发生崩溃，可以通过 **redo log** 来恢复数据文件，从而确保持久性（Durability）



## 事务会不会自动提交

- 在MySQL中，默认情况下事务是自动提交的，每执行一条SQL语句（如INSERT、UPDATE），都会被当作一个事务自动提交

- 如果需要手动控制事务，可以使用 START TRANSACTION 开启事务，并通过 COMMIT 或 ROLLBACK 完成事务。





## 并发事务问题是什么

**1. 脏读**

- 一个事务读到另一个事务还没有提交的数据

**2. 不可重复读**

- 一个事务先后读取同一条事务，但两次读取的数据不同

**3. 幻读**

- 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了幻影



## 事物的隔离级别是什么

|          隔离级别           | 脏读 | 不可重复读 | 幻读 |
| :-------------------------: | :--: | :--------: | :--: |
|      Read Uncommitted       |  ✔   |     ✔      |  ✔   |
|       Read Committed        |  ❌   |     ✔      |  ✔   |
| **Repeatable Read（默认）** |  ❌   |     ❌      |  ✔   |
|        Serializable         |  ❌   |     ❌      |  ❌   |

事务隔离级别越高，数据越安全，但是性能越低



## 如何避免幻读

- 使用Serializable级别

- Repeatable Read 隔离级别下，通过 **间隙锁（Gap Lock）** 避免幻读： 



## 什么是MVCC

多版本并发控制：事务隔离级别的无锁的实现方式，用于提高事务的并发性能

- 隐藏字段
  - DB_TRX_ID：最近修改事务ID
  - DB_ROLL_PTR：指向这条记录的上一个版本
  - DB_ROW_ID：隐藏字段

- 老数据存储在undo log中
- ReadView
  - 快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id
    - m_ids：当前活跃的事务ID集合
    - min_trx_id：最小活跃事务ID
    - max_trx_id：预分配事务ID，当前最大事务ID + 1
    - creator_trx_id：ReadView创建者的事务ID

![二哥的 Java 进阶之路：](https://cdn.tobebetterjavaer.com/stutymore/mysql-20240415094939.png)

![image-20250204114932260](C:/Users/shiyu/AppData/Roaming/Typora/typora-user-images/image-20250204114932260.png)



## 什么是快照读

简单的select（不加锁）就是快照读，快照读读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。

- Read Committed：每次select，都生成一个快照读，保证每次读操作都是最新的数据
- Repeatable Read：开启事务后第一个select语句才是生成快照读的地方，后续读操作都使用这个 ReadView，保证事务内读取的数据是一致的







# 参考资料

黑马程序员MySQL

- P51 - P88 事务到索引
- P121 - P132 锁
- P154 - P157 日志

