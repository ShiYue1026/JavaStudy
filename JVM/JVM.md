# JVM基础

## 什么是JVM

JVM就是Java虚拟机，是Java实现跨平台的基石

![三分恶面渣逆袭：Java语言编译运行](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-1.png)

## JVM的组织架构

![截图来源于网络](https://cdn.tobebetterjavaer.com/stutymore/what-is-jvm-20231030185742.png)

**1. 类加载器**

- 负责从文件系统、网络或其他来源加载 Class 文件，将 Class 文件中的二进制数据读入到内存当中。

**2. 运行时数据区**

- JVM 在执行 Java 程序时，需要在内存中分配空间来处理各种数据，这些内存区域主要包括方法区、堆、栈、程序计数器和本地方法栈。

**3. 执行引擎**

- JVM 的心脏，负责执行字节码。它包括一个虚拟处理器，还包括即时编译器 JIT 和垃圾回收器。



# JVM内存管理

## JVM的内存区域

![三分恶面渣逆袭：Java虚拟机运行时数据区](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-3.png)

**1. 程序计数器**

- 当前线程所执行的字节码行号指示器。

**2. 虚拟机栈**

![三分恶面渣逆袭：Java虚拟机栈](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-4.png)

- Java 虚拟机栈的生命周期与线程相同。

- 当线程执行一个方法时，会创建一个对应的**栈帧**，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，然后栈帧会被压入栈中。当方法执行完毕后，栈帧会从栈中移除。

**3. 本地方法栈**

- 本地方法栈是为 Java 调用**本地（native）方法**服务的，由 C/C++ 编写。

- 在本地方法栈中，主要存放了 native 方法的局部变量、动态链接和方法出口等信息。当一个 Java 程序调用一个 native 方法时，JVM 会切换到本地方法栈来执行这个方法。

**4. 堆**

- 堆是 JVM 中最大的一块内存区域，被所有线程共享，在 JVM 启动时创建，主要用来存储 new 出来的对象。

  ![二哥的 Java 进阶之路：堆](https://cdn.tobebetterjavaer.com/stutymore/neicun-jiegou-20231225154450.png)

- 从内存回收的角度来看，由于垃圾收集器大部分都是基于分代收集理论设计的，所以堆也会被划分为`新生代`、`老年代`、`Eden空间`、`From Survivor空间`、`To Survivor空间`等。

![三分恶面渣逆袭：Java 堆内存结构](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-5.png)

- 从 JDK 7 开始，JVM 已经默认开启逃逸分析了，意味着如果某些方法中的对象引用没有被返回或者未被方法体外使用（也就是未逃逸出去），那么**对象可以直接在栈上分配内存**。



**5. 方法区**

- 方法区并不真实存在，属于 Java 虚拟机规范中的一个逻辑概念，用于存储已被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等。

- 在 HotSpot 虚拟机中，方法区的实现称为永久代（PermGen），但在 Java 8 及之后的版本中，已经被元空间（Metaspace）所替代。

  

![image-20250201233506455](C:/Users/shiyu/AppData/Roaming/Typora/typora-user-images/image-20250201233506455.png)



## 什么是native方法

Native 方法是在 Java 中通过 native 关键字声明的，用于调用非 Java 语言（如 C/C++）编写的代码。Java 可以通过 JNI（Java Native Interface）与底层系统、硬件设备、或高性能的本地库进行交互。





## 一个什么都没有的空方法，完全空的参数什么都没有，那局部变量表里有没有变量？

- 对于静态方法，由于不需要访问实例对象（this），因此在局部变量表中不会有任何变量。
- 对于非静态方法，即使是一个完全空的方法，局部变量表中也会有一个用于**存储 this 引用**的变量。this 引用指向当前实例对象，在方法调用时被隐式传入。



##  JVM中堆和栈的区别是什么

- 堆属于线程共享的内存区域，几乎所有 new 出来的对象都会堆上分配，生命周期不由单个方法调用所决定，可以在方法调用结束后继续存在，直到不再被任何变量引用，**最后被垃圾收集器回收**。
- 栈属于线程私有的内存区域，主要存储局部变量、方法参数、对象引用等，通常随着方法调用的结束而自动释放，**不需要垃圾收集器处理**。



## JDK1.6、1.7、1.8内存区域的变化

主要体现在方法区的实现

- JDK1.6使用永久代实现方法区

  ![JDK 1.6内存区域](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-6.png)

- JDK1.7将字符串常量池、静态变量存放在堆上

  ![JDK 1.7内存区域](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-7.png)

- JDK1.8彻底干掉了永久代，在直接内存中划出一块区域作为**元空间**，运行时常量池、类常量池都移动到元空间

  ![JDK 1.8内存区域](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-8.png)

## 为什么使用元空间替代永久代作为方法区的实现

- 使用永久代来实现方法区的决定的设计导致了 Java 应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize 的上限，即使不设置也有默认大小）



## 对象创建的过程了解吗

- 检查类是否已经被加载、解析和初始化过
  - 使用 new 关键字创建一个对象的时候，JVM 首先会检查 new 指令的参数是否能在常量池中定位到一个类的符号引用然后检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程。（ **类只加载一次，后续对象创建不再触发类加载。**）

- 如果已经加载，JVM为新生对象分配内存
- 将分配到的内存空间初始化为零值
- 设置对象头，对象头里包含了对象是哪个类的实例、对象的哈希码、对象的 GC 分代年龄等信息
- JVM 会执行构造方法（`<init>`），将成员变量赋值为预期的值



## 对象销毁的过程了解吗

- 对象创建完成后，就可以通过引用来访问对象的方法和属性，当对象**不再被任何引用指向时**，对象就会变成垃圾。

- 垃圾收集器会通过可达性分析算法判断对象是否存活，如果对象不可达，就会被回收。
- 垃圾收集器会通过标记清除、标记复制、标记整理等算法来回收内存，将对象占用的内存空间释放出来。



## 什么是指针碰撞和空闲列表

在堆内存分配对象时，主要使用两种策略：指针碰撞和空闲列表。

![三分恶面渣逆袭：指针碰撞和空闲列表](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-10.png)

- 指针碰撞
  - 堆内存必须连续，一部分是已使用的空间，一部分是未使用的房间
  - 在分配内存时，Java 虚拟机维护一个指针，指向下一个可用的内存地址，每次分配内存时，只需要将指针向后移动（碰撞）一段距离，然后将这段内存分配给对象实例即可。
- 空闲列表
  - JVM 维护一个列表，记录堆中所有未占用的内存块，每个空间块都记录了大小和地址信息。
  - 当有新的对象请求内存时，JVM 会遍历空闲列表，寻找足够大的空间来存放新对象。



## JVM里new对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的

**会发生抢占**，假设 JVM 虚拟机上，每一次 new 对象时，指针就会向右移动一个对象 size 的距离，一个线程正在给 A 对象分配内存，指针还没有来的及修改，另一个为 B 对象分配内存的线程，又引用了这个指针来分配内存，这就发生了抢占。

解决方法：

- 采用 CAS 分配重试的方式来保证更新操作的原子性
- 每个线程在 Java 堆中预先分配一小块内存，也就是**本地线程分配缓冲**，要分配内存的线程，先在本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要**同步锁定**。



## 对象的内存布局是什么样的

对象的内存布局因JVM具体实现而异，在HotSpot中，对象在堆内存中的布局可以分为三部分：

**1. 对象头**

- 标记字（Mark Word）
  - 包含了对象自身的运行时数据，如哈希码（HashCode）、垃圾回收分代年龄、锁状态标志、线程持有的锁、偏向线程 ID 等信息。
  - 在 64 位操作系统下占 8 个字节，32 位操作系统下占 4 个字节。

- 类型指针
  - 指向对象所属类的元数据的指针，JVM 通过这个指针来确定对象的类。在开启了压缩指针的情况下，这个指针可以被压缩。
  - 在开启指针压缩的情况下占 4 个字节，否则占 8 个字节。（在 JDK 8 中，压缩指针默认是开启的，以减少 64 位应用中对象引用的内存占用）
- 数组长度
  - 如果对象是数组类型，还会有一个额外的数组长度字段。占 4 个字节。

**2. 实例数据**

- 存储了对象的具体信息，即在类中定义的各种字段数据（不包括由父类继承的字段）。这部分的大小取决于对象的属性和它们的类型（如 int、long、引用类型等）。JVM 会对这些数据进行**对齐**，以确保高效的访问速度。

**3. 对齐填充**

- 为了使对象的总大小是 8 字节的倍数（这在大多数现代计算机体系结构中是最优访问边界），JVM 可能会在对象末尾添加一些填充。

![三分恶面渣逆袭：对象的存储布局](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-12.png)



## Object a = new object()的大小

对象大小 = 对象头 + 实例数据 + 对齐填充

- 对象头的大小在 64 位 JVM 上是 16 字节（如果开启了压缩指针，就是 **12 字节**）  8字节的Mark Word 和 4字节的类型指针

- 实例数据的大小取决于对象的属性和它们的类型。对于`new Object()`来说，Object 类本身没有实例字段，因此这部分可能非常小或者为零。
- 对齐填充的大小取决于对象头和实例数据的大小，以确保对象的总大小是 8 字节的倍数。



`new Object()`的大小是 16 字节（12 字节的对象头 + 4 字节的对齐填充）。



## 对象怎么访问定位

JVM 通过 "对象引用" 访问对象的实际内存地址，不同JVM采用不同的对象访问方式，主要有两种

- 句柄池

  ![通过句柄访问对象](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-13.png)

  - JVM 维护一个 "句柄池（Handle Pool）"，对象引用存储的是 "句柄地址"，而句柄中包含对象的 "数据地址" 和 "类型地址"。

- 直接指针

  ![通过直接指针访问对象](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-14.png)

  - 对象引用存储的就是对象的 "实际地址"，不需要句柄池，直接指向堆中的对象数据。



使用句柄来访问的最大好处就是 reference 中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针

使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销







# 类加载机制

## 类的加载机制是什么

- JVM的操作对象是Class文件，JVM把Class文件中 描述类的数据结构加载到内存中，并对数据进行校验、解析和初始化，最终形成可以被JVM直接使用的类型，这个过程被称为类加载机制。

- **类加载器**：负责加载类文件，将类文件加载到内存中，生成Class对象
- **类加载过程**：加载、验证、准备、解析和初始化
- **双亲委派机制**





## 什么是类加载器

![image-20250202000135012](C:/Users/shiyu/AppData/Roaming/Typora/typora-user-images/image-20250202000135012.png)

- 类加载器（ClassLoader）是JVM提供给应用程序去实现获取类和接口字节码数据的技术



## JDK8及之前和之后的版本中的类加载器有什么区别

- JDK8及之前
  - **启动类加载器Bootstrap**：加载Java中最核心的类，如String
    - 默认加载Java安装目录/jre/lib下的类文件
  - **扩展类加载器Extension**：扩展Java中比较通用但是不重要 的类
    - 默认加载Java安装目录/jre/lib/ext下的类文件
  - **应用程序类加载器Application**：加载应用使用的类，如第三方依赖、自定义的类

- JDK8之后

  - 引入了module模块化的概念，从jmod文件中进行加载

    ![image-20250202104527167](C:/Users/shiyu/AppData/Roaming/Typora/typora-user-images/image-20250202104527167.png)

  - 启动类加载器改为使用Java编写，从模块中找到要加载的字节码资源文件
  - 扩展类加载器被替换成了**平台类加载器(Platform ClassLoader)**，遵循模块化方式加载字节码文件



## 类加载过程是什么样的

**1. 加载**

- 将.class文件加载到JVM，在方法区创建Class对象

**2. 验证**

- 检查.class文件是否符合JVM规范

**3. 准备**

- 为静态变量（`static`变量）分配内存，并初始化默认值（不会执行static赋值或static代码块）

**4. 解析**

- 把类、方法、字段的**符号引用**转换为**直接引用**

**5. 初始化**

- 执行static变量赋值和static代码块



## 一个类什么时候会被加载

**1. 访问类的static变量或static方法**

**2. 创建类的实例**

**3. 使用Class.forName()**

**4. JVM入口类**



## 什么是双亲委派机制

- 由于JVM中有多个类加载器，双亲委派机制的核心是解决一个类到底由谁加载的问题

- 当一个类加载器接收到加载类的任务时，会自底向上查找是否加载过，再由顶向下进行加载

![image-20250202004528115](C:/Users/shiyu/AppData/Roaming/Typora/typora-user-images/image-20250202004528115.png)



## 为什么要用双亲委派机制

**1. 避免类的重复加载**

**2. 保证核心类库的安全性**

- 如`java.lang.*`只能由Bootstrap ClassLoader加载，防止被篡改





## 如何打破双亲委派机制

**1. 自定义类加载器**

- 重写`loadClass()`方法替换掉原始方法中的双亲委派机制的部分

  <img src="C:/Users/shiyu/AppData/Roaming/Typora/typora-user-images/image-20250202010126566.png" alt="image-20250202010126566" style="zoom:50%;" />

- 正确的去实现一个自定义类加载器（不打破双亲委派机制）的方式是重写`findClass()`方法

**2. 线程上下文类加载器（有争议，实际上并没有打破）**

JDBC案例

![image-20250202103237528](C:/Users/shiyu/AppData/Roaming/Typora/typora-user-images/image-20250202103237528.png)

- 启动类加载器加载DriverManager

- 在初始化DriverManager时，通过SPI机制加载jar包中的mysql驱动

- SPI中利用了线程上下文类加载器（应用程序类加载器）去加载类并创建对象

  ![image-20250202103718778](C:/Users/shiyu/AppData/Roaming/Typora/typora-user-images/image-20250202103718778.png)

**3. Osgi框架的类加载器**

- 存在同级之间的类加载器的委托加载

  

## 两个自定义类加载器加载相同类限定名的类，不会冲突吗

不会冲突，在同一个JVM中，只有**相同类加载器 + 相同的类限定名**才会被认为是同一个类。



## 解释执行和编译执行的区别

**解释**：将源代码**逐行**转换为机器码

**编译**：将源代码**一次性**转换为机器码



**解释执行**：程序**运行时**，将源代码**逐行**转换为机器码，然后执行。

**编译执行**：程序**运行前**，将源代码**一次性**转换为机器码，然后执行。



- Java 一般被称为“解释型语言”，因为 Java 代码在执行前，需要先将源代码编译成字节码，然后在运行时，再由 JVM 的解释器“逐行”将字节码转换为机器码，然后执行。

- 这也是 Java 被诟病“慢”的主要原因。

- 但 JIT 的出现打破了这种刻板印象，JVM 会将热点代码（即运行频率高的代码）编译后放入 CodeCache，当下次执行再遇到这段代码时，会从 CodeCache 中直接读取机器码，然后执行。这大大提升了 Java 的执行效率。

  

# 参考资料

- P12 - P19 （类加载器分类到双亲委派机制）
- P48 - P95 （垃圾回收到GC调优）
- P150 - P158 （类加载器）
- P175 - P184 （从CAS看到Synchronized）



