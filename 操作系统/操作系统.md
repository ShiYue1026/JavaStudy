# 引论

## 什么是操作系统？

操作系统是计算机系统中管理硬件和软件资源的中间层系统，屏蔽了硬件的复杂性，并且为用户提供了便捷的交互方式

![三分恶面渣逆袭：操作系统是什么](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-be55aec1-e7ab-433f-97f1-14d99960b6bf.png)



## 操作系统主要有哪些功能

![ 三分恶面渣逆袭：操作系统主要功能](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-eee82952-c96f-45c9-835e-29db37c0f6d8.png)

- 负责创建和终止进程
- 负责为进程分配资源
- 提供创建、删除、读写文件的功能，并组织文件的存储结构，比如说目录
- 通过设备驱动程序控制和管理计算机的硬件设为，如鼠标、键盘、打印机等



# 操作系统结构

## 什么是内核

内核是一个计算机程序，它是操作系统的核心，提供了操作系统最核心的能力，可以控制操作系统中所有的内容。



## 什么是用户态和内核态

在计算机系统中，内存可分为两大区域：**内核空间**和**用户空间**。这种划分主要用户保护系统的稳定性和安全性。

![二哥的 Java 进阶之路：用户空间和内核空间](https://cdn.tobebetterjavaer.com/stutymore/os-20240724170451.png)

- 内核空间
  - 操作系统内核代码及其运行时数据结构所在的内存区域，拥有对系统所有资源的完全访问权限，如进程管理、内存管理、文件系统、网络堆栈等。
- 用户空间
  - 是操作系统为应用程序（如用户运行进程）分配的内存区域，用户空间中的进程不能直接访问硬件或内核数据结构



## 用户态和内核态是如何切换的

当应用程序执行系统调用时，CPU 将从用户态切换到内核态，进入内核空间执行相应的内核代码，然后再切换回用户态。

![三分恶面渣逆袭：用户态&内核态切换](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-b358cdae-18b6-45d4-8a5b-4ea3a7cfc273.png)

系统调用是应用程序请求操作系统内核提供服务的接口，如文件操作（如 open、read、write）、进程控制（如 fork、exec）、内存管理（如 mmap）等。



# 进程和线程

## 并行和并发有什么区别

![并发和并行](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-fb7891d8-8330-494b-9bc1-cf829b5cc82d.png)

并发就是在一段时间内，多个任务都会被处理；**但在某一时刻，只有一个任务在执行。**

- 单核处理器做到的并发，其实是利用时间片的轮转，例如有两个进程 A 和 B，A 运行一个时间片之后，切换到 B，B 运行一个时间片之后又切换到 A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。



并行就是在同一时刻，有多个任务在执行。

- 这需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行这个是物理上的多个进程同时执行。



## 什么是进程上下文切换

![三分恶面渣逆袭：进程上下文切换](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-187d1cf9-971d-4395-b888-5e6eaf2be5f1.png)

上下文切换是操作系统在多任务处理环境中，将CPU从一个进程切换到另一个进程的过程。通过让多个进程共享CPU资源，使系统能够并发执行多个任务。

进程上下文切换包含以下几个步骤：

- 保存当前进程的上下文
  - 操作系统保存当前进程的CPU寄存器，程序状态等关键信息

- 选择下一个进程
  - 调度程序选择下一个要执行的进程
- 恢复上一个进程的上下文
- 切换到下一个进程



## 进程有哪些状态

![进程5种状态](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-ae17a9dc-f555-481a-ba4a-caca06120be7.png)

- 新建状态（New）：进程正在被创建时的状态
- 终止状态（Exit）：进程正在从系统中消失时的状态
- 运行状态（*Runing*）：该时刻进程占用CPU；
- 就绪状态（*Ready*）：可运行，由于其他进程处于运行状态而暂时停⽌运行；
- 阻塞状态（*Blocked*）：该进程正在等待某⼀事件发生（如等待输⼊/输出操作的完成）而暂时停止运行，这时，即使给它 CPU 控制权，它也无法运行；



## 什么是僵尸进程

僵尸进程是已完成且处于终止状态，但在进程表中仍然存在的进程。



**为什么会有僵尸进程**

- 父进程没有调用 `wait()`
  - 如果父进程没有调用 `wait()` 或 `waitpid()`，操作系统不会从进程表中移除子进程的信息，导致子进程变成**僵尸进程**。

- 父进程还在运行，但没有管理子进程
  - 父进程可能**忘记回收子进程**，但它自己仍然在运行，导致子进程进入僵尸状态。



## 什么是孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。

孤儿进程将被 init 进程 (进程 ID 为 1 的进程) 所收养，并由 init 进程对它们完成状态收集工作。因为孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。



## 进程有哪些调度算法

进程调度是操作系统中的核心功能，负责决定哪些进程在何时使用CPU。

**1. 先来先服务**

进程按照请求CPU的顺序进行调度。易于实现，但可能会导致较短的进程等待较长进程执行完成，从而产生“饥饿”现象

![三分恶面渣逆袭：先来先服务](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-93088d03-80c9-46c5-9eaf-eead2adb6e12.png)

**2. 短作业优先**

选择预计运行时间最短的进程优先执行。这种方式可以减少平均等待时间和响应时间，但缺点是很难准确预知进程的执行时间，并且可能因为一直有短作业在执行导致长作业持续被推迟。

![三分恶面渣逆袭：短作业优先](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-517e8392-64fe-4de3-9e1c-b3a944822aba.png)

**3. 优先级调度**

每个进程被分配一个优先级。CPU首先分配给优先级最高的进程。

优先级调度可以是非抢占式的或抢占式的。在非抢占式优先级调度中，进程一旦开始执行将一直运行直到完成；在抢占式优先级调度中，更高优先级的进程可以中断正在执行的低优先级进程。

![三分恶面渣逆袭：优先级调度](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-7c4441cf-7b8c-4660-8ba8-29b8076e2da1.png)

**4. 时间片轮转**

时间片轮转调度为每个进程分配一个固定的时间段，称为时间片，进程可以在这个时间片内运行。如果进程在时间片结束时还没有完成，它将被放回队列的末尾。时间片轮转是公平的调度方式，可以保证所有进程得到公平的 CPU 时间，适用于共享系统。

![三分恶面渣逆袭：时间片轮转](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-ad224c3a-8ac9-4230-84e4-ec434d5b49f9.png)

**5. 最短剩余时间优先**

这是短作业优先的一种改进形式，它是抢占式的。即如果一个新进程的预计执行时间比当前运行进程的剩余时间短，调度器将暂停当前的进程，并切换到新进程。这种方法也可以最小化平均等待时间，但同样面临预测执行时间的困难。

**6. 多级反馈队列**

一个进程需要执行100 个时间片，如果采用时间片轮转调度算法，那么需要交互 100 次。

多级队列就是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列的时间片大小不同，比如 2,4,6,8······。进程在第一个队列没执行完，就会被移到下一个队列。

这种方式下，之前的进程只需要交换 7 次就可以了。每个队列优先权不一样，最上面的队列优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

![DIDA-lJ-多级反馈队列](https://cdn.tobebetterjavaer.com/stutymore/os-20240426094524.png)



## 进程间通信有哪些方式

![编程十万问：进程间通信](https://cdn.tobebetterjavaer.com/stutymore/os-20240314073226.png)

**1. 管道**

- 管道可以理解成不同进程之间的传话筒，一方发声，一方接收

- **进程间的管道就是内核中的一串缓存**，从管道的一端写入数据，另一端读取。数据只能单向流动，遵循先进先出（FIFO）的原则。

- 缺点：管道的效率低，不适合进程间频繁地交换数据。

  ![编程十万问：管道](https://cdn.tobebetterjavaer.com/stutymore/os-20240314073535.png)

**2. 信号**

- 用于通知接收进程某件事情发生了，是一种较为简单的通信方式，主要用于处理异步事件。
- 常用信号
  - SIGHUP：当我们退出终端（Terminal）时，由该终端启动的所有进程都会接收到这个信号，默认动作为终止进程。
  - SIGINT：程序终止（interrupt）信号。按 `Ctrl+C` 时发出，大家应该在操作终端时有过这种操作。
  - SIGQUIT：和 SIGINT 类似，按 `Ctrl+\` 键将发出该信号。它会产生核心转储文件，将内存映像和程序运行时的状态记录下来。
  - SIGKILL：强制杀死进程，本信号不能被阻塞和忽略。
  - SIGTERM：与 SIGKILL 不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出。

**3. 消息队列**

- 消息队列是保存在内核中的消息链表，按照消息的类型进行消息传递，具有较高的可靠性和稳定性。

- 缺点：消息体有一个最大长度的限制，不适合比较大的数据传输；存在用户态与内核态之间的数据拷贝开销。

  ![编程十万问：消息队列](https://cdn.tobebetterjavaer.com/stutymore/os-20240314075045.png)

**4. 共享内存**

- 允许两个或多个进程共享一个给定的内存区，一个进程写入的东西，其他进程马上就能看到。

- 共享内存是最快的进程间通信方式，它是针对其他进程间通信方式运行效率低而专门设计的。

- 缺点：当多进程竞争同一个共享资源时，会造成数据错乱的问题。

  ![三分恶面渣逆袭：共享内存](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-d9e3cfaf-01e7-42ff-9290-94ef4a5c7d5e.png)

**5. 信号量**

- 信号量可以理解成红绿灯，红灯停（信号量为零），绿灯行（信号量非零）。**它本质上是一个计数器**，用来控制对共享资源的访问数量。

  ![三分恶面渣逆袭：信号量](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-5fb765af-918c-4037-a3ad-4cad4d985e16.png)

**6. 套接字**

- 提供网络通信的端点，可以让不同机器上运行的进程之间进行双向通信。

![img](https://cdn.tobebetterjavaer.com/stutymore/os-20240314082438.png)



## 进程和线程的联系和区别

- 进程是一个正在执行的程序实例。每个进程都有自己独立的地址空间、全局变量、堆栈、和文件描述符等资源。

- 线程是进程中的一个执行单元。一个进程可以包含多个线程，它们共享进程的地址空间和资源。

- 进程切换需要保存和恢复大量的上下文信息，代价较高。线程切换相对较轻量，因为线程共享进程的地址空间，**只需要保存和恢复线程私有的数据。**
- 线程的生命周期由进程控制，进程终止时，其所有线程也会终止。

| 特性       | 进程                         | 线程                             |
| ---------- | ---------------------------- | -------------------------------- |
| 地址空间   | 独立                         | 共享                             |
| 内存开销   | 高                           | 低                               |
| 上下文切换 | 慢，开销大                   | 快，开销小                       |
| 通信       | 需要 IPC 机制，开销较大      | 共享内存，直接通信               |
| 创建销毁   | 开销大，较慢                 | 开销小，较快                     |
| 并发性     | 低                           | 高                               |
| 崩溃影响   | 一个进程崩溃不会影响其他进程 | 一个线程崩溃可能导致整个进程崩溃 |



## 线程上下文切换了解吗

- 当两个线程不是属于同⼀个进程，则切换的过程就跟进程上下文切换⼀样；
- 当两个线程属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据

所以，线程的上下文切换相比进程开销要小很多



## 线程有哪些实现方式

**1. 内核态线程实现**

- 在内核空间实现的线程，由内核直接管理直接管理线程

  ![内核态线程实现](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-30b84285-8027-4720-b50b-3b0fb18c756f.png)

**2. 用户态线程实现**

- 在用户空间实现线程，不需要内核的参与，内核对线程无感知

  ![用户态线程](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-57886181-56fe-42bf-85e1-4d062455788a.png)

**3.混合线程实现**

- 现代操作系统基本都是将两种方式结合起来使用。用户态的执行系统负责进程内部线程在非阻塞时的切换；内核态的操作系统负责阻塞线程的切换。

- 多个用户级线程（N）映射到多个内核级线程（M），即 N:M 线程调度。

  ![混合线程实现](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-1597d159-1b07-48ae-ac86-7e9b9cb85876.png)



## 用户态线程和内核态线程有什么区别

**用户级线程（ULT）**：

- **优点**：上下文切换快（不需要内核干预）。
- **缺点**：不能利用多核 CPU，且如果一个线程阻塞，整个进程都会被挂起。

**内核级线程（KLT）**：

- **优点**：支持多核 CPU 并行执行，线程阻塞不影响其他线程。
- **缺点**：线程切换涉及内核态，**开销大**（寄存器切换、TLB 刷新）。



## 线程间如何同步

同步解决的是多线程操作共享资源的问题，不管线程之间是如何穿插执行的，最后的结果都是正确的。

![cxuan：使用临界区的互斥](https://cdn.tobebetterjavaer.com/stutymore/javathread-20241008102844.png)

**临界区**：对共享资源访问的程序片段，我们希望这段代码是`互斥`的，可以保证在某个时刻只能被一个线程执行，也就是说一个线程在临界区执行时，其它线程应该被阻止进入临界区。



**1. 互斥锁**:

- 使用加锁操作和解锁操作可以解决并发线程/进程的互斥问题。
- 任何想进⼊临界区的线程，必须先执行加锁操作。若加锁操作顺利通过，则线程可进入临界区；在完成对临界资源的访问后再执行解锁操作，以释放该临界资源。
- 根据锁的实现不同，可以分为`忙等待锁`和`⽆忙等待锁`。
  - 忙等待锁（也称为自旋锁，Spinlock）是指当一个线程试图获取锁时，如果该锁已经被其他线程持有，当前线程不会立即进入休眠或阻塞，而是不断地检查锁的状态，直到该锁可用为止。
    - 优点是避免了线程的上下文切换
    - 缺点是浪费CPU资源
  - 无忙等待锁是指当一个线程尝试获取锁时，如果锁已经被其他线程持有，当前线程不会忙等待，而是主动让出 CPU，进入阻塞状态或休眠状态，等待锁释放
  - 当锁被释放时，线程被唤醒并重新尝试获取锁。

**2. 信号量**

信号量是操作系统提供的⼀种协调共享资源访问的方法。**通常表示资源的数量**，对应的变量是⼀个整型（sem）变量。

另外，还有两个原子操作的系统调用函数来控制信号量，分别是：

- *P* 操作：当线程想要进入临界区时，会尝试执行 P 操作。如果信号量的值大于 0，信号量值减 1，线程可以进入临界区；否则，线程会被阻塞，直到信号量大于 0。
- *V* 操作：当线程退出临界区时，执行 V 操作，信号量的值加 1，释放一个被阻塞的线程。



## 什么是死锁

在两个或者多个并发线程中，如果每个线程持有某种资源，而又等待其它线程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组线程产生了死锁。



## 死锁产生有哪些条件

产生死锁需要同时满足四个必要条件:

- **互斥条件**
  - 资源不能被多个进程共享
  - 如果一个资源已经被分配给了一个进程，其他进程必须等待，直到该资源被释放。
- **持有并等待**
  - 一个进程已经持有了至少一个资源,同时还在等待获取其它被占用的资源, 这个期间不会释放已经持有的资源
- **不可剥夺**
  - 已分配给进程的资源不能被强制剥夺，只有持有该资源的进程可以主动释放资源
- **循环等待**
  - 存在一个进程集合 P1,P2,...,Pn，其中 P1 等待 P2 持有的资源，P2 等待 P3 持有的资源，依此类推，直到 Pn 等待 P1 持有的资源，形成一个进程等待环。



## 如何避免死锁

打破任意一个条件即可

**消除互斥条件**

这个是没法实现，因为很多资源就是只能被一个线程占用，例如锁。

**消除请求并持有条件**

消除这个条件的办法很简单，就是一个线程一次请求其所需要的所有资源。

**消除不可剥夺条件**

占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可剥夺这个条件就破坏掉了。

**消除循环等待条件**

可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了。



## 活锁和饥饿锁了解吗

**饥饿锁**

- 这个饥饿指的是资源饥饿, 某个线程一直等不到它所需要的资源,从而无法向前推进

**活锁**

- 两个线程不断互相让步，导致没有线程能真正完成任务





# 内存管理

