# 数据库和表结构

## 项目中是否进行了分库分表

使用了**Shardingsphere**中间件进行了**垂直分库**（按照不同的业务进行拆分）+ **水平分库**（每个业务内进行拆分）+ **水平分表**



## 为什么在用户表外额外设计用户手机表和用户邮箱表？

![密码登录.jpg](https://cdn.nlark.com/yuque/0/2024/jpeg/22643320/1723691960114-1045b61f-03f3-455d-afa0-5e959558738f.jpeg?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_6Zi_5pif5LiN5piv56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

用户登录时，可以用手机号或邮箱登录，也就是需要用手机号和邮箱来查询用户信息；而在订单业务中需要用用户id查询用户信息。分库分表使用的是用户id作为分片键，使用手机号 和 邮箱查询用户信息会造成**全路由问题**。



**解决方案：**

![用户登录.png](https://cdn.nlark.com/yuque/0/2024/png/22643320/1723691907122-269cd4f3-d201-4759-aeeb-becaaad43b54.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_6Zi_5pif5LiN5piv56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

为了解决这个全路由问题，采用附属表方案，设置了用户手机表和用户邮箱表，分片键是手机号和邮箱，先通过手机号或邮箱查询到用户id，然后使用用户id查询用户表，这样就解决了问题。



**缺点：**

- 多了一步查询的过程，额外产生了性能的消耗
- 额外多了用户手机表和用户邮箱表，随着数据量的越来越大，表容量的占用也越来越大



## 项目中哪里使用了基因法

在订单业务中，即需要根据用户id查询订单，又需要根据订单号查询订单

假设分片数是N，用用户id的后$log_2N$位替换掉订单号的后$log_2N$位，二者对N的取模的结果相同。

- 可以保证一个用户所有订单号一定会分片同一个库和表中
- 通过该用户的id或订单号都可以直接定位到这张表上，不需要全路由



假设存在一种情况，在超高的并发下，在同一毫秒，同一台机器，生成两个id，那么这两个id唯一的区别就是序列号相差1，如果这时我们使用了基因法，那么这两个id不就重复了吗？

- 确需要用户在同一毫秒下创建了2个订单才能重复，要是正常的用户肯定是不会重复的，除非是机器刷单或者恶意攻击这种情况











# 网关服务



# 用户服务



# 节目服务



# 订单服务

## 订单超时取消功能为什么使用Redisson而不是用RocketMQ

**RocketMQ的缺点**

- RocketMQ的延迟消息依赖固定的时间级别，例如 **1s、5s、10s、30s...**，但不支持自定义毫秒级的精确延迟。

- MQ **是基于 FIFO（先进先出）模式**，如果MQ发生消息堆积，RocketMQ的延迟消息可能会之后，导致任务无法按预期时间执行。

**Redisson的解决方案**

- Redisson **基于 Redis 的 `ZSet`（有序集合）** 进行延迟任务调度，任务按照 `score` 排序，Redisson 只会获取 **到期的任务**，不受未到期任务数量影响，**即使有 1000 万条任务堆积，Redisson 也只会取出到期任务进行消费**，而不会遍历所有任务。**可以做到毫秒级精度**，保证任务按时执行。
- **不会因消息堆积而影响执行时间**，即使 Redis 任务积压，也能通过**定时轮询** 精准执行任务。
- 当 Redisson 客户端重启时，`RDelayedQueue` 的状态会被自动恢复，因为其状态是持久化在 Redis 中的。这意味着即使应用重启，延迟队列的功能也不会受到影响



且能减少一个中间件依赖，因为几乎所有项目都会依赖redis



## 如何实现高性能延迟队列



docker run -d --name myredis \
  -p 6379:6379 \
  redis:latest \
  redis-server --requirepass root

# 支付服务





